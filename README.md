# Boolean Function Minimization (Project 2)

This program implements Boolean function minimization using the Quine-McCluskey algorithm and Petrick's method.

## Project Overview

- **Input**: Single-output Boolean function in PLA format (with don't cares)
- **Algorithm**: 
  1. Quine-McCluskey algorithm → find all Prime Implicants (PIs)
  2. Petrick's Algorithm → find minimal SOP cover(s)
- **Output**: Minimized PLA format with statistics

## Compilation Instructions (Linux/WSL)

### Prerequisites
- g++ compiler with C++11 support
- make utility

### Build Commands

#### 1. Build the program (Release version)
```bash
make
```
This will compile the program with optimization flags (-O2) and generate the executable `minimize`.

#### 2. Build debug version (optional)
```bash
make debug
```
This will compile the program with debug symbols (-g) and no optimization (-O0), generating `minimize_debug`.

#### 3. Clean build artifacts
```bash
make clean
```
This removes all compiled object files (.o), executables, and output PLA files.

## Usage

### Method 1: Direct execution
```bash
./minimize <input.pla> <output.pla>
```

**Example:**
```bash
./minimize pla_files/test1.pla output_pla/test1_output.pla
```

### Method 2: Using Makefile shortcuts
```bash
make test1.pla
```
This will automatically:
- Read from `pla_files/test1.pla`
- Output to `output_pla/test1_output.pla`
- Display the minimized result

**Available test files:**
```bash
make test1.pla    # 4-variable function
make test2.pla    # 5-variable function
make test3.pla    # 6-variable function
make input.pla    # Original input file
```

### Method 3: Quick test with default file
```bash
make run
```
or
```bash
make test
```
This runs the program on `pla_files/input.pla` and outputs to `output_pla/input_output.pla`.

## Test Cases

### Test Case 1: 4-variable function (`test1.pla`)
- Variables: A, B, C, D
- On-set minterms: m0, m1, m2, m3, m5, m8, m12, m13
- Don't cares: m4, m9

### Test Case 2: 5-variable function (`test2.pla`)
- Variables: A, B, C, D, E
- On-set minterms: m0, m1, m4, m5, m8, m16, m17, m18, m24, m25, m30
- Don't cares: m2, m9, m12, m28

### Test Case 3: 6-variable function (`test3.pla`)
- Variables: A, B, C, D, E, F
- On-set minterms: m0, m1, m2, m8, m9, m16, m17, m18, m20, m32, m33, m34, m40, m48, m56
- Don't cares: m4, m12, m18, m36, m49, m60

## PLA Format

### Input Format
```
.i N              # number of inputs (4-6 variables)
.o 1              # number of outputs (must be 1)
.ilb v1 v2 ...    # input variable names
.ob output_name   # output name
.p K              # number of product terms
<input_cube> <output>
...
.e                # end marker
```

- Input cube: `0` (false), `1` (true), `-` (don't care)
- Output: `1` (on-set), `-` (don't care)

### Output Format
The output PLA file contains:
- Minimized product terms
- Statistics comment:
  - Number of product terms
  - Total number of literals

**Example output:**
```
# Minimized Boolean Function
# Generated by Quine-McCluskey + Petrick's Algorithm
# Statistics:
#   Product terms: 4
#   Total literals: 8

.i 4
.o 1
.ilb A B C D
.ob F
.p 4
-0-0 1
-01- 1
10-- 1
-1-1 1
.e
```

## Algorithm Details

### Quine-McCluskey Algorithm
1. **Grouping**: Group minterms by number of 1s
2. **Combining**: Iteratively combine adjacent terms (differ by 1 bit)
3. **Prime Implicants**: Mark terms that cannot be combined further

### Petrick's Method
1. **Coverage Chart**: Build Prime Implicant coverage chart
2. **Essential PIs**: Find essential Prime Implicants
3. **Covering Problem**: Solve remaining coverage using Boolean algebra
4. **Minimal Solution**: Select solution with fewest literals

## Project Structure
```
DSD_Project_02/
├── src/
│   ├── main.cpp              # Entry point and workflow
│   ├── PlaParser.cpp/h       # PLA file parser
│   ├── QuineMcCluskey.cpp/h  # Quine-McCluskey algorithm
│   ├── Petrick.cpp/h         # Petrick's algorithm
│   └── PlaWriter.cpp/h       # PLA output writer
├── pla_files/                # Input test PLA files
│   ├── test1.pla            # 4-variable test case
│   ├── test2.pla            # 5-variable test case
│   ├── test3.pla            # 6-variable test case
│   └── input.pla            # Original input
├── output_pla/               # Output directory (auto-created)
├── Makefile                  # Build configuration
└── README.md                 # This file
```

## Output Statistics

The program reports:
- **Number of product terms**: Count of AND terms in the minimized SOP
- **Total literals**: Sum of all literals in the expression

Lower numbers indicate better minimization.

## Implementation Status

- [x] PLA parser with don't care support
- [x] Quine-McCluskey algorithm
- [x] Petrick's algorithm  
- [x] PLA output writer with statistics
- [x] Complete workflow integration
- [x] Test cases (4, 5, 6 variables)

## Notes

This is Project 2 for Digital System Design course, focusing on Boolean function minimization using the Quine-McCluskey algorithm and Petrick's method.

## Author

Digital System Design Course - Project 2
Date: October 2025
